[
  {
    "title": "ServerFire",
    "websites": ["GitHub"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "JavaScript",
      "Node.js"
    ],
    "thumbnail": "/assets/npm-logo.png",
    "description": "ServerFire is a lightweight JavaScript server framework that is 100% modular and a seventh the size of the leading Node.js server library, Express!\n\nDesigned to have zero external dependencies, the library is relatively simple, but its modular middleware system enables infinite possibilities! It is largely inspired by Express, since it was designed as a lightweight alternative with a relatively flat learning curve, and does use a list of file type indicators from ~$[sindresorhus](https://github.com/sindresorhus)'s NPM package, ~$[file-type](https://github.com/sindresorhus/file-type), which is linked in a comment in the corresponding code, but everything else, and the simplifications of the code used as inspiration, was made by me.\n\nServerFire originally began as a web server library called ~$[ServerLight](https://github.com/AmazingMech2418/ServerLight), which I made as a solution to Express' large file size, which was clogging the storage on my Repl.it account. I started using it for websites I made, but realized I needed to be able to do more, so I started working on a new library, which I called AdminServer. It was designed to be like Express, but less bulky and with built-in middlewares for website management. And eventually, when I got tired of copying dozens of files between projects each time I used it, I wanted to publish it to NPM as well! However, \"AdminServer\" was too close to an existing name, so I renamed it as ServerFire! Since then, I have worked on this package and improved it, and soon, ServerFire 2.0 will come out, with more powerful features and an even more lightweight codebase!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/ServerFire"
      },
      {
        "label": "NPM Package: ",
        "url": "https://npmjs.com/package/serverfire"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AmazingMech2418/ServerFire"
      },
      {
        "label": "Demo Website: ",
        "url": "https://serverfire.amazingmech2418.repl.co/"
      }
    ],
    "images": ["/assets/serverfire/demosite.png", "/assets/serverfire/npmpage.png"],
    "score": 100
  },
  {
    "title": "Self-XSS Protection Feature",
    "websites": ["GitHub"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "JavaScript"
    ],
    "thumbnail": "/assets/github-logo.png",
    "description": "Too often, people run code themselves (through the JavaScript console, bookmarklets, or by pressing XSS-infected buttons or links) that contains malicious HTTP requests, such as cookie grabbers or malicious in-site endpoints, to obtain access to user accounts. Or even, there is simply an XSS vulnerability in the website that enables code to be run regardless of how careful the user is. Most of the harm is when a request is made without the user's knowledge. This script enables the user to know what requests are being made and to decide whether or not to allow them.\n\nThis Self-XSS Protection script is a single-file script that can be added into any website to improve security for users. The owner of the website just needs to update the script to allow certain endpoints, using the documentation in the GitHub repository, and when any non-native request is made, the user will see an alert box to confirm or deny the request. If confirmed, similar requests will always be allowed, but if denied, the request will be blocked.\n\nThis project started due to a discussion on the ~$[Scratch forums](https://scratch.mit.edu/discuss) about the potential banning of sharing bookmarklets. As a maker of many bookmarklets, I suggested that instead of banning them, a new security feature be implemented to prevent their dangers while maintaining their functionality. Then, I created this GitHub repository! After making this, I talked to ~$[@Paddle2See](https://scratch.mit.edu/users/Paddle2See), a Scratch Team member, to ask about its potential implementation, and he discussed it with the engineering team. Unfortunately, the idea was rejected due to the overhead required to implement the script on every page, but I still maintain this project as a security feature open to use on other websites!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/Self-XSS-Protection"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AustinStitz/XSS-Protection-Demo"
      },
      {
        "label": "Demo Website: ",
        "url": "https://xss-protection-demo.austinstitz.repl.co/"
      }
    ],
    "images": ["/assets/xss/xssdemo.png", "/assets/xss/xssrepo.png"],
    "score": 100
  },
  {
    "title": "Space Observatory",
    "websites": ["Unpublished"],
    "status": "Abandoned",
    "types": ["Software"],
    "langs": [
      "Python",
      "JavaScript",
      "Bash",
      "HTML"
    ],
    "thumbnail": "/assets/observatory/nasa-logo.webp",
    "description": "Between 8th and 9th grade, I wanted to be able to track all things NASA, and made this project! Some parts, such as RSS feeds and podcasts, still work, but some also use APIs that have become obsolete. The project is partially broken, but since I plan to make a more modular version eventually anyways, and have learned much more since making this about server-client communications, I will not continue to update this project and plan to create a new dashboard application that will do the same things as this!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AustinMichael2418/Space-Observatory"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AustinStitz/Space-Observatory"
      },
      {
        "label": "Demo Website: ",
        "url": "https://space-observatory.austinstitz.repl.co/"
      }
    ],
    "images": ["/assets/observatory/observatory-main.png", "/assets/observatory/spacex.png", "/assets/observatory/nasa-live.png", "/assets/observatory/nasa-podcast.png", "/assets/observatory/nasa-rss.png"],
    "score": 50
  },
  {
    "title": "QSH",
    "websites": ["Unpublished"],
    "status": "In-Progress",
    "types": ["Software"],
    "langs": [
      "Java",
      "QUIL"
    ],
    "thumbnail": "/assets/qsh/quantum.jpg",
    "description": "When I was in 10th grade, I took AP Computer Science through North Carolina Virtual Public Schools, since my school didn't have any spots open in the class, and amidst the COVID-19 pandemic, our school prevented schedule changes unless for graduation requirements. One discussion post assignment then introduced me to quantum computing, and I ended up going down a rabbit-hole, learning more about quantum computing and the QUantum Instruction Language (QUIL). And when it came to be time to complete my final project for that class, I thought about the difficulties I faced in trying to learn quantum computing, with such limited resources available, and realized what we were missing: a REPL shell for QUIL.\n\nSo, I made it! I wrote my own QUIL interpreter, quantum simulation engine, and terminal UI, and created a program that could simulate quantum circuits using the QUIL language, without requiring a quantum computer! While the ~$[IBM Quantum Experience](https://quantum-computing.ibm.com/) existed, I noticed it used the wrong reset function, simply setting the qbit to 0 rather than swapping it out for a new one. And the drag-and-drop user interface didn't explain anything about circuits or gates, and did not teach the QUIL language at all. So, the lack of an accurate quantum simulator and UI inspired me to create QSH!\n\nQSH is still in-progress, despite me not having worked on it in about two years now. Once I have more time, with school out and college applications done, I hope to continue it and add features like parametric circuits, and maybe even expand it to a full computational shell, including paradigms including probabilistic and DNA computing! Both using and making QSH have helped me learn more about quantum computing as a field, and I hope, once I finish it, that it can help others in similar ways!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AustinMichael2418/QSH"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AustinStitz/QSH"
      },
      {
        "label": "QUIL Specifications: ",
        "url": "https://github.com/quil-lang/quil/blob/master/spec/Quil.md"
      },
      {
        "label": "Original Quantum Instruction Set Specifications: ",
        "url": "https://arxiv.org/pdf/1608.03355.pdf"
      }
    ],
    "images": ["/assets/qsh/qsh1.png", "/assets/qsh/qsh2.png", "/assets/qsh/qsh3.png", "/assets/qsh/qsh4.png"],
    "score": 99
  },
  {
    "title": "ScratchCloud",
    "websites": ["GitHub", "Scratch"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "JavaScript",
      "Node.js",
      "Scratch (language)",
      "SQL"
    ],
    "thumbnail": "/assets/scratch-logo.jpg",
    "description": "On Scratch, the famous block coding website, there is a feature that very few people know much about how to use: cloud variables. People know it's for sharing information between users through a project, or possibly between a user and external server acting as a user, but actually implementing it is difficult. It is especially difficult when you want to control one end programmatically, outside of Scratch. I made ScratchCloud to make that easier.\n\nWith security features being added to the website, authentication through older libraries fails, making this one of the only libraries for cloud manipulation that actually works! This specific implementation is built for Node.js and includes both synchronous and asynchronous APIs to interface with the websockets cloud variables run on. Although still prone to the regular glitches of cloud data, ScratchCloud allows you to connect Scratch projects to the outside world!\n\nAs an example of ScratchCloud, I have also included in this project page, my CloudSocket RSA-protected authentication system from my participation in OS Wars, a competition for operating system simulators in Scratch.",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/ScratchCloud"
      },
      {
        "label": "NPM Package: ",
        "url": "https://www.npmjs.com/package/scratchcloud"
      },
      {
        "label": "CloudSocket Scratch Project: ",
        "url": "https://scratch.mit.edu/projects/470009600/"
      },
      {
        "label": "CloudSocket Backend on Repl.it: ",
        "url": "https://replit.com/@AmazingMech2418/CloudSocket-RedOS-Login"
      }
    ],
    "images": ["/assets/cloud/sc-npm.png", "/assets/cloud/sc-repo.png"],
    "score": 98
  },
  {
    "title": "Wordle.AI",
    "websites": ["Repl.it"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "Haskell"
    ],
    "thumbnail": "/assets/repl-logo.png",
    "description": "Who doesn't like ~$[Wordle](https://www.nytimes.com/games/wordle/index.html)?\n\nYet, despite how fun the beloved word game is, sometimes, finding the word can be challenging! And when you are so intent on keeping your win streak, you ~${{<i>need</i>}} to win! So, I created a Wordle solver: Wordle.AI! The program looks at a list of words in the English language and, using letter frequencies, finds the best starting word, and based on the results from typing that word into the game, the best guess for each round until you get the answer!\n\nWriting this in Haskell was relatively challenging since it was my first major program in the beloved functional programming language. But I was able to figure it out! The hardest part was the file I/O to read the wordlist, but the Haskell documentation is amazing, and I found everything I needed!\n\nOverall, this was a fun project to make, although pretty difficult! It taught me a lot about Haskell and allowed me to maintain my Wordle streak during very difficult words! (Don't worry, I did not use the AI most of the time, just when I was desperately confused!)",
    "links": [
      {
        "label": "Repl.it Project: ",
        "url": "https://replit.com/@AmazingMech2418/WordleAI"
      }
    ],
    "images": ["/assets/wordleai/wordleai.png", "/assets/wordleai/wordle.png"],
    "score": 99
  },
  {
    "title": "Pi in Many Languages",
    "websites": ["Repl.it", "GitHub"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "Ada", "APL", "Bash", "BASIC", "QBasic", "C", "C++", "COBOL", "Ruby/Crystal", "C#", "D", "Dart", "Elixir", "Erlang", "Forth", "Fortran", "F#", "Go", "Haskell", "Haxe", "Java", "JavaScript", "Node.js", "CoffeeScript", "TypeScript", "Julia", "Kotlin", "Lisp", "Scheme", "Clojure", "Emacs Lisp", "LOLCODE", "Lua", "Nim", "Objective-C", "Pascal", "PHP", "Prolog", "Python", "R", "Perl/Raku", "Reason Node.js", "Rust", "Scala", "Swift", "Tcl", "V", "Zig"
    ],
    "thumbnail": "/assets/repl-logo.png",
    "description": "When the COVID-19 pandemic hit during the spring and summer of 2020, and literally everything closed down, I decided to use the time to explore new programming languages I had never programmed in. This project began with ~$[@LizFoster](https://replit.com/@LizFoster), an online friend on Repl.it, making her many pi approximations and sharing them on the website. I had already made my ~$[C approximations](https://replit.com/talk/share/p-Approximations-in-C/33461) during a competition with ~$[@StudentFires](https://replit.com/@StudentFires), but then decided to make ~$[two more programs](https://replit.com/talk/share/2-Approximations-of-p-In-Only-Four-Lines-of-Code/32773), each with two approximations, in Python and Node.js, each code-golfed.\n\nI was then dared by ~$[@Warhawk947](https://replit.com/@Warhawk947) to write an approximation in ~$[LOLCODE](https://replit.com/talk/share/p-in-LOLCODE/34421), an esoteric programming language based entirely on a meme! And from there, I just continued, making pi approximations in as many languages as I could on Repl.it! Although a few of the earlier approximations also use the arctangent infinite series to find arctan(1) = pi/4 and then multiply by 4 to get pi, most of these use the Nilakantha Series to find pi.\n\nThe hardest part of this project was finding documentation. Once I found it, making the programs was relatively straight-forward, but lesser-used languages, such as APL, didn’t have as much available. But taking on this challenge, I got a taste of 46 different programming languages and dialects, which allowed me to better choose which ones I wanted to focus on. If it weren’t for this project, I would have never found Haskell, which is one of my favorite programming languages now, and I wouldn’t have been exposed to older languages like Fortran and COBOL which are also quite fun to program in!",
    "links": [
      {
        "label": "Latest Repl.it Post: ",
        "url": "https://replit.com/talk/share/p-in-COBOL/140260"
      },
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/Pi-in-Many-Languages"
      }
    ],
    "images": [],
    "score": 87
  },
  {
    "title": "BrainFC",
    "websites": ["Repl.it", "GitHub"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "C", "BrainF***"
    ],
    "thumbnail": "/assets/github-logo.png",
    "description": "BrainF (abbreviated due to profanity in the name) is one of the hardest programming languages to program in. It has just 8 commands: \".\", \",\", \"<\", \">\", \"[\", \"]\", \"+\", and \"-\". Every other character in the program is simply ignored. Yet, the challenge of programming in it makes it more fun! That’s why I started to learn it and program in it.\n\nBut, ~$[Repl.it](https://replit.com)'s default BrainF interpreter didn’t work for multi-character inputs, so I made a new interpreter in C! Using arrays and pointers, and even a dynamic pointer array for a call stack and file reading, I fixed the issue with Repl.it’s interpreter by simply making my own.\n\nThe code is relatively simple, everything fitting in a single 109-line file, but the greatest challenges were finding out how to avoid segmentation faults while working with pointer arrays and figuring out how to read a file in C. I had only used basic user input in my C programs before, so this was my first time using file I/O in a C program. \n\nI also used the concepts of BrainFC to make a ~$[BrainF compiler in Java](https://replit.com/@AmazingMech2418/BrainF-Compiler), but the demo on Repl.it unfortunately doesn’t seem to be working currently, perhaps due to the ~$[update to Nix](https://blog.replit.com/nix). Both of these only work for Linux currently, since that is what Repl.it runs on, due to the need to change terminal settings to allow multi-character inputs.",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/BrainFC"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AmazingMech2418/BrainF-in-C"
      }
    ],
    "images": [],
    "score": 87
  },
  {
    "title": "NCVPS PTC Tech Support AI",
    "websites": ["GitHub"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "HTML", "JavaScript"
    ],
    "thumbnail": "/assets/ncvpsptc/ptc-logo.jpg",
    "description": "I have worked with the North Carolina Virtual Public Schools Peer Tutoring Center since 8th grade, including as a part of the Tech Support team. In Tech Support, I have created multiple tutorial videos with information on how to fix bugs in the tools used by NCVPS, such as Canvas and Upswing (for peer tutoring), as well as general bugs such as in Google Chrome.\n\nTo better allow students to find these videos, I created the \"Tech Support AI!\" It isn’t really an AI, but since virtual assistants are sometimes called \"AIs\" falsely, I originally called it one when I started the project three years ago. It’s really more of a search engine, which allows the user to search through videos, using their transcripts and titles to find keywords in the search. It also supports voice search, using Google Chrome's speech-to-text API.\n\nThe greatest challenge making this was connecting the website to a Google Sheets spreadsheet to get the data needed to display the videos, since everything was connected to a spreadsheet that was auto-populated by a Google Form. I ultimately found that I could use a Repl.it API endpoint that uses wget to obtain the CSV data to then return to the website for processing. Everything else was much more straight-forward, including designing the search algorithm and implementing the voice search, which was made easier by a previous project of mine: ~$[SpeakJS](https://github.com/AmazingMech2418/SpeakJS).",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/ncvpsptc/ai"
      },
      {
        "label": "Live Website: ",
        "url": "https://ncvpsptc.github.io/ai/"
      }
    ],
    "images": ["/assets/ncvpsptc/ai-homepage.PNG", "/assets/ncvpsptc/tech-support-page.PNG"],
    "score": 70
  }
]
