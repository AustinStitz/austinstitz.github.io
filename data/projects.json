[
  {
    "title": "ServerFire",
    "websites": ["GitHub"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "JavaScript",
      "Node.js"
    ],
    "thumbnail": "/assets/npm-logo.png",
    "description": "ServerFire is a lightweight JavaScript server framework that is 100% modular and a seventh the size of the leading Node.js server library, Express!\n\nDesigned to have zero external dependencies, the library is relatively simple, but its modular middleware system enables infinite possibilities! It is largely inspired by Express, since it was designed as a lightweight alternative with a relatively flat learning curve, and does use a list of file type indicators from ~$[sindresorhus](https://github.com/sindresorhus)'s NPM package, ~$[file-type](https://github.com/sindresorhus/file-type), which is linked in a comment in the corresponding code, but everything else, and the simplifications of the code used as inspiration, was made by me.\n\nServerFire originally began as a web server library called ~$[ServerLight](https://github.com/AmazingMech2418/ServerLight), which I made as a solution to Express' large file size, which was clogging the storage on my Repl.it account. I started using it for websites I made, but realized I needed to be able to do more, so I started working on a new library, which I called AdminServer. It was designed to be like Express, but less bulky and with built-in middlewares for website management. And eventually, when I got tired of copying dozens of files between projects each time I used it, I wanted to publish it to NPM as well! However, \"AdminServer\" was too close to an existing name, so I renamed it as ServerFire! Since then, I have worked on this package and improved it, and soon, ServerFire 2.0 will come out, with more powerful features and an even more lightweight codebase!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/ServerFire"
      },
      {
        "label": "NPM Package: ",
        "url": "https://npmjs.com/package/serverfire"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AmazingMech2418/ServerFire"
      },
      {
        "label": "Demo Website: ",
        "url": "https://serverfire.amazingmech2418.repl.co/"
      }
    ],
    "images": ["/assets/serverfire/demosite.png", "/assets/serverfire/npmpage.png"],
    "score": 100
  },
  {
    "title": "Self-XSS Protection Feature",
    "websites": ["GitHub"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "JavaScript"
    ],
    "thumbnail": "/assets/github-logo.png",
    "description": "Too often, people run code themselves (through the JavaScript console, bookmarklets, or by pressing XSS-infected buttons or links) that contains malicious HTTP requests, such as cookie grabbers or malicious in-site endpoints, to obtain access to user accounts. Or even, there is simply an XSS vulnerability in the website that enables code to be run regardless of how careful the user is. Most of the harm is when a request is made without the user's knowledge. This script enables the user to know what requests are being made and to decide whether or not to allow them.\n\nThis Self-XSS Protection script is a single-file script that can be added into any website to improve security for users. The owner of the website just needs to update the script to allow certain endpoints, using the documentation in the GitHub repository, and when any non-native request is made, the user will see an alert box to confirm or deny the request. If confirmed, similar requests will always be allowed, but if denied, the request will be blocked.\n\nThis project started due to a discussion on the ~$[Scratch forums](https://scratch.mit.edu/discuss) about the potential banning of sharing bookmarklets. As a maker of many bookmarklets, I suggested that instead of banning them, a new security feature be implemented to prevent their dangers while maintaining their functionality. Then, I created this GitHub repository! After making this, I talked to ~$[@Paddle2See](https://scratch.mit.edu/users/Paddle2See), a Scratch Team member, to ask about its potential implementation, and he discussed it with the engineering team. Unfortunately, the idea was rejected due to the overhead required to implement the script on every page, but I still maintain this project as a security feature open to use on other websites!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/Self-XSS-Protection"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AustinStitz/XSS-Protection-Demo"
      },
      {
        "label": "Demo Website: ",
        "url": "https://xss-protection-demo.austinstitz.repl.co/"
      }
    ],
    "images": ["/assets/xss/xssdemo.png", "/assets/xss/xssrepo.png"],
    "score": 100
  },
  {
    "title": "Space Observatory",
    "websites": ["Unpublished"],
    "status": "Abandoned",
    "types": ["Software"],
    "langs": [
      "Python",
      "JavaScript",
      "Bash",
      "HTML"
    ],
    "thumbnail": "/assets/observatory/nasa-logo.webp",
    "description": "Between 8th and 9th grade, I wanted to be able to track all things NASA, and made this project! Some parts, such as RSS feeds and podcasts, still work, but some also use APIs that have become obsolete. The project is partially broken, but since I plan to make a more modular version eventually anyways, and have learned much more since making this about server-client communications, I will not continue to update this project and plan to create a new dashboard application that will do the same things as this!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AustinMichael2418/Space-Observatory"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AustinStitz/Space-Observatory"
      },
      {
        "label": "Demo Website: ",
        "url": "https://space-observatory.austinstitz.repl.co/"
      }
    ],
    "images": ["/assets/observatory/observatory-main.png", "/assets/observatory/spacex.png", "/assets/observatory/nasa-live.png", "/assets/observatory/nasa-podcast.png", "/assets/observatory/nasa-rss.png"],
    "score": 50
  },
  {
    "title": "QSH",
    "websites": ["Unpublished"],
    "status": "In-Progress",
    "types": ["Software"],
    "langs": [
      "Java",
      "QUIL"
    ],
    "thumbnail": "/assets/qsh/quantum.jpg",
    "description": "When I was in 10th grade, I took AP Computer Science through North Carolina Virtual Public Schools, since my school didn't have any spots open in the class, and amidst the COVID-19 pandemic, our school prevented schedule changes unless for graduation requirements. One discussion post assignment then introduced me to quantum computing, and I ended up going down a rabbit-hole, learning more about quantum computing and the QUantum Instruction Language (QUIL). And when it came to be time to complete my final project for that class, I thought about the difficulties I faced in trying to learn quantum computing, with such limited resources available, and realized what we were missing: a REPL shell for QUIL.\n\nSo, I made it! I wrote my own QUIL interpreter, quantum simulation engine, and terminal UI, and created a program that could simulate quantum circuits using the QUIL language, without requiring a quantum computer! While the ~$[IBM Quantum Experience](https://quantum-computing.ibm.com/) existed, I noticed it used the wrong reset function, simply setting the qbit to 0 rather than swapping it out for a new one. And the drag-and-drop user interface didn't explain anything about circuits or gates, and did not teach the QUIL language at all. So, the lack of an accurate quantum simulator and UI inspired me to create QSH!\n\nQSH is still in-progress, despite me not having worked on it in about two years now. Once I have more time, with school out and college applications done, I hope to continue it and add features like parametric circuits, and maybe even expand it to a full computational shell, including paradigms including probabilistic and DNA computing! Both using and making QSH have helped me learn more about quantum computing as a field, and I hope, once I finish it, that it can help others in similar ways!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AustinMichael2418/QSH"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AustinStitz/QSH"
      },
      {
        "label": "QUIL Specifications: ",
        "url": "https://github.com/quil-lang/quil/blob/master/spec/Quil.md"
      },
      {
        "label": "Original Quantum Instruction Set Specifications: ",
        "url": "https://arxiv.org/pdf/1608.03355.pdf"
      }
    ],
    "images": ["/assets/qsh/qsh1.png", "/assets/qsh/qsh2.png", "/assets/qsh/qsh3.png", "/assets/qsh/qsh4.png"],
    "score": 99
  },
  {
    "title": "ScratchCloud",
    "websites": ["GitHub", "Scratch"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "JavaScript",
      "Node.js",
      "Scratch (language)",
      "SQL"
    ],
    "thumbnail": "/assets/scratch-logo.jpg",
    "description": "On Scratch, the famous block coding website, there is a feature that very few people know much about how to use: cloud variables. People know it's for sharing information between users through a project, or possibly between a user and external server acting as a user, but actually implementing it is difficult. It is especially difficult when you want to control one end programmatically, outside of Scratch. I made ScratchCloud to make that easier.\n\nWith security features being added to the website, authentication through older libraries fails, making this one of the only libraries for cloud manipulation that actually works! This specific implementation is built for Node.js and includes both synchronous and asynchronous APIs to interface with the websockets cloud variables run on. Although still prone to the regular glitches of cloud data, ScratchCloud allows you to connect Scratch projects to the outside world!\n\nAs an example of ScratchCloud, I have also included in this project page, my CloudSocket RSA-protected authentication system from my participation in OS Wars, a competition for operating system simulators in Scratch.",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/ScratchCloud"
      },
      {
        "label": "NPM Package: ",
        "url": "https://www.npmjs.com/package/scratchcloud"
      },
      {
        "label": "CloudSocket Scratch Project: ",
        "url": "https://scratch.mit.edu/projects/470009600/"
      },
      {
        "label": "CloudSocket Backend on Repl.it: ",
        "url": "https://replit.com/@AmazingMech2418/CloudSocket-RedOS-Login"
      }
    ],
    "images": ["/assets/cloud/sc-npm.png", "/assets/cloud/sc-repo.png"],
    "score": 98
  },
  {
    "title": "Wordle.AI",
    "websites": ["Repl.it"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "Haskell"
    ],
    "thumbnail": "/assets/repl-logo.png",
    "description": "Who doesn't like ~$[Wordle](https://www.nytimes.com/games/wordle/index.html)?\n\nYet, despite how fun the beloved word game is, sometimes, finding the word can be challenging! And when you are so intent on keeping your win streak, you ~${{<i>need</i>}} to win! So, I created a Wordle solver: Wordle.AI! The program looks at a list of words in the English language and, using letter frequencies, finds the best starting word, and based on the results from typing that word into the game, the best guess for each round until you get the answer!\n\nWriting this in Haskell was relatively challenging since it was my first major program in the beloved functional programming language. But I was able to figure it out! The hardest part was the file I/O to read the wordlist, but the Haskell documentation is amazing, and I found everything I needed!\n\nOverall, this was a fun project to make, although pretty difficult! It taught me a lot about Haskell and allowed me to maintain my Wordle streak during very difficult words! (Don't worry, I did not use the AI most of the time, just when I was desperately confused!)",
    "links": [
      {
        "label": "Repl.it Project: ",
        "url": "https://replit.com/@AmazingMech2418/WordleAI"
      }
    ],
    "images": ["/assets/wordleai/wordleai.png", "/assets/cloud/wordle.png"],
    "score": 99
  }
]
