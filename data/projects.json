[
  {
    "title": "ServerFire",
    "websites": ["GitHub"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "JavaScript",
      "Node.js"
    ],
    "thumbnail": "/assets/npm-logo.png",
    "description": "ServerFire is a lightweight JavaScript server framework that is 100% modular and a seventh the size of the leading Node.js server library, Express!\n\nDesigned to have zero external dependencies, the library is relatively simple, but its modular middleware system enables infinite possibilities! It is largely inspired by Express, since it was designed as a lightweight alternative with a relatively flat learning curve, and does use a list of file type indicators from ~$[sindresorhus](https://github.com/sindresorhus)'s NPM package, ~$[file-type](https://github.com/sindresorhus/file-type), which is linked in a comment in the corresponding code, but everything else, and the simplifications of the code used as inspiration, was made by me.\n\nServerFire originally began as a web server library called ~$[ServerLight](https://github.com/AmazingMech2418/ServerLight), which I made as a solution to Express' large file size, which was clogging the storage on my Repl.it account. I started using it for websites I made, but realized I needed to be able to do more, so I started working on a new library, which I called AdminServer. It was designed to be like Express, but less bulky and with built-in middlewares for website management. And eventually, when I got tired of copying dozens of files between projects each time I used it, I wanted to publish it to NPM as well! However, \"AdminServer\" was too close to an existing name, so I renamed it as ServerFire! Since then, I have worked on this package and improved it, and soon, ServerFire 2.0 will come out, with more powerful features and an even more lightweight codebase!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/ServerFire"
      },
      {
        "label": "NPM Package: ",
        "url": "https://npmjs.com/package/serverfire"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AmazingMech2418/ServerFire"
      },
      {
        "label": "Demo Website: ",
        "url": "https://serverfire.amazingmech2418.repl.co/"
      }
    ],
    "images": ["/assets/serverfire/demosite.png", "/assets/serverfire/npmpage.png"],
    "score": 100
  },
  {
    "title": "Self-XSS Protection Feature",
    "websites": ["GitHub"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "JavaScript"
    ],
    "thumbnail": "/assets/github-logo.png",
    "description": "Too often, people run code themselves (through the JavaScript console, bookmarklets, or by pressing XSS-infected buttons or links) that contains malicious HTTP requests, such as cookie grabbers or malicious in-site endpoints, to obtain access to user accounts. Or even, there is simply an XSS vulnerability in the website that enables code to be run regardless of how careful the user is. Most of the harm is when a request is made without the user's knowledge. This script enables the user to know what requests are being made and to decide whether or not to allow them.\n\nThis Self-XSS Protection script is a single-file script that can be added into any website to improve security for users. The owner of the website just needs to update the script to allow certain endpoints, using the documentation in the GitHub repository, and when any non-native request is made, the user will see an alert box to confirm or deny the request. If confirmed, similar requests will always be allowed, but if denied, the request will be blocked.\n\nThis project started due to a discussion on the ~$[Scratch forums](https://scratch.mit.edu/discuss) about the potential banning of sharing bookmarklets. As a maker of many bookmarklets, I suggested that instead of banning them, a new security feature be implemented to prevent their dangers while maintaining their functionality. Then, I created this GitHub repository! After making this, I talked to ~$[@Paddle2See](https://scratch.mit.edu/users/Paddle2See), a Scratch Team member, to ask about its potential implementation, and he discussed it with the engineering team. Unfortunately, the idea was rejected due to the overhead required to implement the script on every page, but I still maintain this project as a security feature open to use on other websites!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/Self-XSS-Protection"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AustinStitz/XSS-Protection-Demo"
      },
      {
        "label": "Demo Website: ",
        "url": "https://xss-protection-demo.austinstitz.repl.co/"
      }
    ],
    "images": ["/assets/xss/xssdemo.png", "/assets/xss/xssrepo.png"],
    "score": 100
  },
  {
    "title": "Space Observatory",
    "websites": ["Unpublished"],
    "status": "Abandoned",
    "types": ["Software"],
    "langs": [
      "Python",
      "JavaScript",
      "Bash",
      "HTML"
    ],
    "thumbnail": "/assets/observatory/nasa-logo.webp",
    "description": "Between 8th and 9th grade, I wanted to be able to track all things NASA, and made this project! Some parts, such as RSS feeds and podcasts, still work, but some also use APIs that have become obsolete. The project is partially broken, but since I plan to make a more modular version eventually anyways, and have learned much more since making this about server-client communications, I will not continue to update this project and plan to create a new dashboard application that will do the same things as this!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AustinMichael2418/Space-Observatory"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AustinStitz/Space-Observatory"
      },
      {
        "label": "Demo Website: ",
        "url": "https://space-observatory.austinstitz.repl.co/"
      }
    ],
    "images": ["/assets/observatory/observatory-main.png", "/assets/observatory/spacex.png", "/assets/observatory/nasa-live.png", "/assets/observatory/nasa-podcast.png", "/assets/observatory/nasa-rss.png"],
    "score": 50
  },
  {
    "title": "QSH",
    "websites": ["Unpublished"],
    "status": "In-Progress",
    "types": ["Software"],
    "langs": [
      "Java",
      "QUIL"
    ],
    "thumbnail": "/assets/qsh/quantum.jpg",
    "description": "When I was in 10th grade, I took AP Computer Science through North Carolina Virtual Public Schools, since my school didn't have any spots open in the class, and amidst the COVID-19 pandemic, our school prevented schedule changes unless for graduation requirements. One discussion post assignment then introduced me to quantum computing, and I ended up going down a rabbit-hole, learning more about quantum computing and the QUantum Instruction Language (QUIL). And when it came to be time to complete my final project for that class, I thought about the difficulties I faced in trying to learn quantum computing, with such limited resources available, and realized what we were missing: a REPL shell for QUIL.\n\nSo, I made it! I wrote my own QUIL interpreter, quantum simulation engine, and terminal UI, and created a program that could simulate quantum circuits using the QUIL language, without requiring a quantum computer! While the ~$[IBM Quantum Experience](https://quantum-computing.ibm.com/) existed, I noticed it used the wrong reset function, simply setting the qbit to 0 rather than swapping it out for a new one. And the drag-and-drop user interface didn't explain anything about circuits or gates, and did not teach the QUIL language at all. So, the lack of an accurate quantum simulator and UI inspired me to create QSH!\n\nQSH is still in-progress, despite me not having worked on it in about two years now. Once I have more time, with school out and college applications done, I hope to continue it and add features like parametric circuits, and maybe even expand it to a full computational shell, including paradigms including probabilistic and DNA computing! Both using and making QSH have helped me learn more about quantum computing as a field, and I hope, once I finish it, that it can help others in similar ways!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AustinMichael2418/QSH"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AustinStitz/QSH"
      },
      {
        "label": "QUIL Specifications: ",
        "url": "https://github.com/quil-lang/quil/blob/master/spec/Quil.md"
      },
      {
        "label": "Original Quantum Instruction Set Specifications: ",
        "url": "https://arxiv.org/pdf/1608.03355.pdf"
      }
    ],
    "images": ["/assets/qsh/qsh1.png", "/assets/qsh/qsh2.png", "/assets/qsh/qsh3.png", "/assets/qsh/qsh4.png"],
    "score": 99
  },
  {
    "title": "ScratchCloud",
    "websites": ["GitHub", "Scratch"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "JavaScript",
      "Node.js",
      "Scratch (language)",
      "SQL"
    ],
    "thumbnail": "/assets/scratch-logo.jpg",
    "description": "On Scratch, the famous block coding website, there is a feature that very few people know much about how to use: cloud variables. People know it's for sharing information between users through a project, or possibly between a user and external server acting as a user, but actually implementing it is difficult. It is especially difficult when you want to control one end programmatically, outside of Scratch. I made ScratchCloud to make that easier.\n\nWith security features being added to the website, authentication through older libraries fails, making this one of the only libraries for cloud manipulation that actually works! This specific implementation is built for Node.js and includes both synchronous and asynchronous APIs to interface with the websockets cloud variables run on. Although still prone to the regular glitches of cloud data, ScratchCloud allows you to connect Scratch projects to the outside world!\n\nAs an example of ScratchCloud, I have also included in this project page, my CloudSocket RSA-protected authentication system from my participation in OS Wars, a competition for operating system simulators in Scratch.",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/ScratchCloud"
      },
      {
        "label": "NPM Package: ",
        "url": "https://www.npmjs.com/package/scratchcloud"
      },
      {
        "label": "CloudSocket Scratch Project: ",
        "url": "https://scratch.mit.edu/projects/470009600/"
      },
      {
        "label": "CloudSocket Backend on Repl.it: ",
        "url": "https://replit.com/@AmazingMech2418/CloudSocket-RedOS-Login"
      }
    ],
    "images": ["/assets/cloud/sc-npm.png", "/assets/cloud/sc-repo.png"],
    "score": 98
  },
  {
    "title": "Wordle.AI",
    "websites": ["Repl.it"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "Haskell"
    ],
    "thumbnail": "/assets/repl-logo.png",
    "description": "Who doesn't like ~$[Wordle](https://www.nytimes.com/games/wordle/index.html)?\n\nYet, despite how fun the beloved word game is, sometimes, finding the word can be challenging! And when you are so intent on keeping your win streak, you ~${{<i>need</i>}} to win! So, I created a Wordle solver: Wordle.AI! The program looks at a list of words in the English language and, using letter frequencies, finds the best starting word, and based on the results from typing that word into the game, the best guess for each round until you get the answer!\n\nWriting this in Haskell was relatively challenging since it was my first major program in the beloved functional programming language. But I was able to figure it out! The hardest part was the file I/O to read the wordlist, but the Haskell documentation is amazing, and I found everything I needed!\n\nOverall, this was a fun project to make, although pretty difficult! It taught me a lot about Haskell and allowed me to maintain my Wordle streak during very difficult words! (Don't worry, I did not use the AI most of the time, just when I was desperately confused!)",
    "links": [
      {
        "label": "Repl.it Project: ",
        "url": "https://replit.com/@AmazingMech2418/WordleAI"
      }
    ],
    "images": ["/assets/wordleai/wordleai.png", "/assets/wordleai/wordle.png"],
    "score": 99
  },
  {
    "title": "Pi in Many Languages",
    "websites": ["Repl.it", "GitHub"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "Ada", "APL", "Bash", "BASIC", "QBasic", "C", "C++", "COBOL", "Ruby/Crystal", "C#", "D", "Dart", "Elixir", "Erlang", "Forth", "Fortran", "F#", "Go", "Haskell", "Haxe", "Java", "JavaScript", "Node.js", "CoffeeScript", "TypeScript", "Julia", "Kotlin", "Lisp", "Scheme", "Clojure", "Emacs Lisp", "LOLCODE", "Lua", "Nim", "Objective-C", "Pascal", "PHP", "Prolog", "Python", "R", "Perl/Raku", "Reason Node.js", "Rust", "Scala", "Swift", "Tcl", "V", "Zig"
    ],
    "thumbnail": "/assets/repl-logo.png",
    "description": "When the COVID-19 pandemic hit during the spring and summer of 2020, and literally everything closed down, I decided to use the time to explore new programming languages I had never programmed in. This project began with ~$[@LizFoster](https://replit.com/@LizFoster), an online friend on Repl.it, making her many pi approximations and sharing them on the website. I had already made my ~$[C approximations](https://replit.com/talk/share/p-Approximations-in-C/33461) during a competition with ~$[@StudentFires](https://replit.com/@StudentFires), but then decided to make ~$[two more programs](https://replit.com/talk/share/2-Approximations-of-p-In-Only-Four-Lines-of-Code/32773), each with two approximations, in Python and Node.js, each code-golfed.\n\nI was then dared by ~$[@Warhawk947](https://replit.com/@Warhawk947) to write an approximation in ~$[LOLCODE](https://replit.com/talk/share/p-in-LOLCODE/34421), an esoteric programming language based entirely on a meme! And from there, I just continued, making pi approximations in as many languages as I could on Repl.it! Although a few of the earlier approximations also use the arctangent infinite series to find arctan(1) = pi/4 and then multiply by 4 to get pi, most of these use the Nilakantha Series to find pi.\n\nThe hardest part of this project was finding documentation. Once I found it, making the programs was relatively straight-forward, but lesser-used languages, such as APL, didn’t have as much available. But taking on this challenge, I got a taste of 46 different programming languages and dialects, which allowed me to better choose which ones I wanted to focus on. If it weren’t for this project, I would have never found Haskell, which is one of my favorite programming languages now, and I wouldn’t have been exposed to older languages like Fortran and COBOL which are also quite fun to program in!",
    "links": [
      {
        "label": "Latest Repl.it Post: ",
        "url": "https://replit.com/talk/share/p-in-COBOL/140260"
      },
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/Pi-in-Many-Languages"
      }
    ],
    "images": [],
    "score": 87
  },
  {
    "title": "BrainFC",
    "websites": ["Repl.it", "GitHub"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "C", "BrainF***"
    ],
    "thumbnail": "/assets/github-logo.png",
    "description": "BrainF (abbreviated due to profanity in the name) is one of the hardest programming languages to program in. It has just 8 commands: \".\", \",\", \"<\", \">\", \"[\", \"]\", \"+\", and \"-\". Every other character in the program is simply ignored. Yet, the challenge of programming in it makes it more fun! That’s why I started to learn it and program in it.\n\nBut, ~$[Repl.it](https://replit.com)'s default BrainF interpreter didn’t work for multi-character inputs, so I made a new interpreter in C! Using arrays and pointers, and even a dynamic pointer array for a call stack and file reading, I fixed the issue with Repl.it’s interpreter by simply making my own.\n\nThe code is relatively simple, everything fitting in a single 109-line file, but the greatest challenges were finding out how to avoid segmentation faults while working with pointer arrays and figuring out how to read a file in C. I had only used basic user input in my C programs before, so this was my first time using file I/O in a C program. \n\nI also used the concepts of BrainFC to make a ~$[BrainF compiler in Java](https://replit.com/@AmazingMech2418/BrainF-Compiler), but the demo on Repl.it unfortunately doesn’t seem to be working currently, perhaps due to the ~$[update to Nix](https://blog.replit.com/nix). Both of these only work for Linux currently, since that is what Repl.it runs on, due to the need to change terminal settings to allow multi-character inputs.",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/BrainFC"
      },
      {
        "label": "Repl.it Demo: ",
        "url": "https://replit.com/@AmazingMech2418/BrainF-in-C"
      }
    ],
    "images": [],
    "score": 87
  },
  {
    "title": "NCVPS PTC Tech Support AI",
    "websites": ["GitHub"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "HTML", "JavaScript"
    ],
    "thumbnail": "/assets/ncvpsptc/ptc-logo.jpg",
    "description": "I have worked with the North Carolina Virtual Public Schools Peer Tutoring Center since 8th grade, including as a part of the Tech Support team. In Tech Support, I have created multiple tutorial videos with information on how to fix bugs in the tools used by NCVPS, such as Canvas and Upswing (for peer tutoring), as well as general bugs such as in Google Chrome.\n\nTo better allow students to find these videos, I created the \"Tech Support AI!\" It isn’t really an AI, but since virtual assistants are sometimes called \"AIs\" falsely, I originally called it one when I started the project three years ago. It’s really more of a search engine, which allows the user to search through videos, using their transcripts and titles to find keywords in the search. It also supports voice search, using Google Chrome's speech-to-text API.\n\nThe greatest challenge making this was connecting the website to a Google Sheets spreadsheet to get the data needed to display the videos, since everything was connected to a spreadsheet that was auto-populated by a Google Form. I ultimately found that I could use a Repl.it API endpoint that uses wget to obtain the CSV data to then return to the website for processing. Everything else was much more straight-forward, including designing the search algorithm and implementing the voice search, which was made easier by a previous project of mine: ~$[SpeakJS](https://github.com/AmazingMech2418/SpeakJS).",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/ncvpsptc/ai"
      },
      {
        "label": "Live Website: ",
        "url": "https://ncvpsptc.github.io/ai/"
      }
    ],
    "images": ["/assets/ncvpsptc/ai-homepage.PNG", "/assets/ncvpsptc/tech-support-page.PNG"],
    "score": 70
  },
  {
    "title": "PDF2Project",
    "websites": ["GitHub", "Scratch"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "HTML", "JavaScript", "Scratch (language)"
    ],
    "thumbnail": "/assets/pdf2project/pdf-logo.png",
    "description": "On ~$[Scratch](https://scratch.mit.edu/), there is a tri-annual writing camp, called Scratch Writing Camp (SWC). Having been a part of SWC since 2020, once the Scratch Team banned ~$[Blank Slate](https://blankslate.io/), a website commonly used for sharing writing for SWC, I decided to make a new, working alternative. Many people moved to the Scratch forums, but I started working on a project that could turn any PDF into a PDF-viewing Scratch project.\n\nI had already created a ~$[website to convert gifs to Scratch sprites](https://github.com/scratch-tools/gif2sprite), which would work to an extent after converting a PDF to a gif, but it added an extra step that was mostly unnecessary. Modifying Gif2Sprite, I created ~$[PDF2Sprite](https://github.com/scratch-tools/PDF2Sprite), which did the same thing, except for a PDF rather than a gif. And with just a little more modification, I created PDF2Project, which generated an entire project rather than just a single sprite.\n\nPDF2Sprite uses a few JavaScript libraries: ~$[file-saver](https://www.npmjs.com/package/file-saver), ~$[JSZip](https://www.npmjs.com/package/jszip), ~$[SparkMD5](https://www.npmjs.com/package/spark-md5), and ~$[PDF.js](https://www.npmjs.com/package/pdfjs-dist). The file-saver library was needed to download binary files, JSZip to create zip files, SparkMD5 to hash files as MD5, and PDF.js to read the PDFs. Using these libraries, I used JavaScript to allow the website to read the pages of PDFs as images, MD5 hash the image contents to name the images, add the images to a zip file, add the proper Scratch code to a JSON file in the zip file, and download the zip file as an SB3 Scratch project.",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/scratch-tools/PDF2Project"
      },
      {
        "label": "Live Website: ",
        "url": "https://scratch-tools.github.io/PDF2Project/"
      }
    ],
    "images": ["/assets/pdf2project/pdf2project1.PNG", "/assets/pdf2project/pdf2project2.PNG", "/assets/pdf2project/pdf2project3.PNG", "/assets/pdf2project/pdf2project4.PNG"],
    "score": 88
  },
  {
    "title": "S3Extend",
    "websites": ["GitHub", "Scratch"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "JavaScript", "Scratch (language)"
    ],
    "thumbnail": "/assets/scratchx-logo.png",
    "description": "Scratch extensions are scripts that you can use to add blocks to the ~$[Scratch](https://scratch.mit.edu/) editor. Some are already available, such as Pen, Music, or Text to Speech, but others are called “experimental extensions,” and are made by users on the website who create scripts that can add the blocks. During Scratch 2.0, making experimental extensions was extremely common, and even promoted by ~$[ScratchX](https://scratchx.org/)! There was a block on sharing projects with these, but it was easy to get around, and people still shared projects with experimental extensions regardless. But, when Scratch updated to 3.0, in order to outlive Flash Player, the ~$[VM](https://github.com/LLK/scratch-vm) became encapsulated inside a React component, making it inaccessible to normal JavaScript scripts. And since registering extensions was done inside the VM, experimental Scratch extensions could not be loaded.\n\nThen, I found ~$[a project](https://scratch.mit.edu/projects/717031217/) that used an experimental extension, just it would only work in ~$[TurboWarp](https://turbowarp.org/). I had already experimented with exposing the VM through React DevTools, but just needed to find how to do it programmatically. After some research, I found out how to expose a React fiber to then traverse to find the component itself and created a script to do that. Using that script, I then used React DevTools to find the target element to find the component for, and ran the function on that element to get the component, which would expose the properties, which would expose the VM. Using this, I then globalized the VM and modified the extension registering script to get it to work, and I tested it, and it worked!\n\nBut when I tried making my own extension, I saw an error while trying to load it. It turned out experimental extensions needed to have a recognized ID, that was either one of a pre-existing extension or block category. Looking through the Scratch source code, I found that an unused block type was used to help with the transition from Scratch 2.0 to Scratch 3.0: math. And that just happened to be the extension ID of the extension in the project I had found! So, any extension had to have an ID of \"math.\"\n\nBut that meant that only one extension could be loaded at a time. So, I decided to create a wrapper for multiple extensions in a single project: S3Extend. Applying the VM-globalizing script and the basic extension format, as well as defining a few additional wrapper functions for registering extensions, I made S3Extend, using buttons to separate and label different extensions. However, this is still in-progress, and I did notice a bug where loading a second extension causes S3Extend to show in the block menu twice, but one time with the first extension and the second time with both. I still have to figure out what causes this bug and how to fix it, but the script otherwise works, and I have tested it with old extensions I created back when the documentation was first released.",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/S3Extend"
      }
    ],
    "images": ["/assets/s3extend/s3extend.PNG"],
    "score": 80
  },
  {
    "title": "ScratchForth",
    "websites": ["GitHub", "Scratch"],
    "status": "Maintained",
    "types": ["Software"],
    "langs": [
      "JavaScript", "Node.js", "Scratch (language)", "Forth"
    ],
    "thumbnail": "/assets/scratch-logo.jpg",
    "description": "In 2021, I competed in ~$[Anonymous Accounts 10](https://scratch.mit.edu/studios/29953429/), a competition on ~$[Scratch](https://scratch.mit.edu/) where users create \"namesnipe\" accounts and have to guess who owns the accounts. I had helped create scripts to track/modify user agents, tell when messages were checked on Scratch, and search studio comments for keywords, to help online friends who competed in previous seasons of Anonymous Accounts keep their accounts secret and discover who ran the other accounts, but Anonymous Accounts 10 was my first time actually competing, and I created ~$[@pyzen](https://scratch.mit.edu/users/pyzen). My account combined the stereotypical spammer on Scratch with the open-source fanatic who ironically doesn’t utilize the basic principles of open-source software. The name comes from a combination of the Zen of Python and the beloved Intel alternative, the AMD Ryzen series of processors. But, ironically, the account produced some of the most over-complicated code possible, violating every aspect of the Zen of Python. And that over-complicated code included a new binary format for Scratch.\n\nI decided to create Scratch Binary Format, originally as a part of this joke, but then realized it could be used to help introduce Scratchers (people who use Scratch) to text-based programming languages through running Scratch projects with compiled Scratch Binary Format code. If and when new compilers for major programming languages are made, you could program in real text-based languages, but also use these to create Scratch projects!\n\nThe first compiler to Scratch Binary Format was ScratchForth, a dialect of Forth for controlling Scratch projects. Since I had a time crunch for Anonymous Accounts 10, a Forth compiler was one of the easiest compilers I could have made, so I made the compiler run on a Forth dialect rather than a more complicated programming language.\n\nDespite using postfix notation for functions, ScratchForth’s control features are really more like BASIC than Forth, using labels, GOTO statements, and function calls that mimicked those from BASIC or even Assembly. Modules mirroring C/C++ are also supported for multi-file programs.",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/ScratchForth"
      },
      {
        "label": "Demo Project: ",
        "url": "https://github.com/AmazingMech2418/ScratchForth"
      }
    ],
    "images": ["/assets/sfth/sfth-repo.PNG", "/assets/sfth/sfth-project.PNG"],
    "score": 80
  },
  {
    "title": "Lambda Factorial",
    "websites": ["GitHub"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "JavaScript", "Haskell", "Python"
    ],
    "thumbnail": "/assets/lambda/lambda.png",
    "description": "As I was researching the history of computing I came across one of the first computing paradigms ever created: Lambda Calculus. Created by Alonzo Church, who was also Alan Turing's teacher and mentor, Lambda Calculus lays out the foundations of modern functional programming. With nothing but functions, parameters, and applications--and functions only being able to take one parameter--, it is difficult to program in, but has been proven to be Turing-complete, thanks to recursion and various fixed-point combinators. The behavior of fixed-point combinators depends on the interpreter (as I found out with ~$[my failed interpreter on Scratch](https://scratch.mit.edu/projects/735059540/)), usually either the y-combinator or z-combinator will work.\n\nTo practice Lambda Calculus, I decided to make a basic program in three different programming languages using nothing but lambdas. Since JavaScript, Haskell, and Python all have this functionality, I used those languages. Using z-combinators and Church notation, I created a factorial function! It was difficult to figure out how everything worked at first, but I was able to figure it out, and learning more about this computational system was overall very rewarding!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/Lambda-Factorial/"
      }
    ],
    "images": [],
    "score": 80
  },
  {
    "title": "PrimeExt",
    "websites": ["GitHub", "Scratch"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "JavaScript", "Scratch (language)"
    ],
    "thumbnail": "/assets/scratchx-logo.png",
    "description": "PrimeExt was an intermediary project for the development of ~$[S3Extend](https://austinstitz.github.io/projects/view/#S3Extend). It started out as a Scratch extension for Scratch 2.0, designed to aid in the fast calculation of the primality of numbers, but then developed into a demonstration for Scratch extensions in Scratch 3.0. I used this to learn more about the Scratch 3.0 extension format, as well as apply my React component extractor that is then able to register the extension. I also learned of the bug where only extensions with the ID \"math\" will save, which is why this extension does not allow you to save the project.\n\nThis project is complete as of now and can be properly integrated into S3Extend for demonstrations. However, it is mostly still up as a relic of the past of the new wrapper for extensions in Scratch 3.0.",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/PrimeExt"
      }
    ],
    "images": ["/assets/primeext/primeext.PNG"],
    "score": 60
  },
  {
    "title": "Elections Console",
    "websites": ["Repl.it"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "JavaScript", "Node.js"
    ],
    "thumbnail": "/assets/repl-logo.png",
    "description": "During the 2020 election, I noticed that President Biden's victory was announced before many key states were completely decided. Using CNN's election results map, I calculated the probability of swings from the current trajectories and realized that many of the states that were \"decided\" according to the map had above 0% chance of a swing, which frustrated me. So, to obtain more accurate results about when the election was completely decided, I created a Node.js program to calculate the probability of victory for either side.\n\nCalculating the chance of a swing for each state based on the existing percentages and the percent of polls reporting, I determined which states had officially decided results and which just had a lean one way or the other, and for those with a lean, I used the probabilities of a flip to the other candidate to calculate an average results chance. Using the available electoral votes for undecided states, I also showed the best-case scenarios for either party/candidate. Ultimately, the election wasn't actually decided until a week after it was originally called, and even states like Georgia, Wisconsin, and Arizona had the potential to switch candidates at 99% of the polls reporting with how close the presidential races in those states were.",
    "links": [
      {
        "label": "Repl.it Project: ",
        "url": "https://replit.com/@AmazingMech2418/Elections-Console"
      }
    ],
    "images": ["/assets/repl/elections1.PNG", "/assets/repl/elections2.PNG"],
    "score": 19
  },
  {
    "title": "Little Man Computer",
    "websites": ["Repl.it"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "C"
    ],
    "thumbnail": "/assets/repl-logo.png",
    "description": "The Little Man Computer, or LMC, is a simple von Neumann architecture computer simulator used to teach the low-level functionalities of computers. With an analogy of a person in a mail room, there are 100 data addresses, or mailboxes, numbered 0 to 99, each with three-digit data from 000 to 999. Using these as memory locations, the LMC reads the relevant instructions and pulls the relevant stored data to complete computations.\n\nTo learn more about this, I decided to make a LMC simulator in C! As an example program, I also used the Fibbonacci sequence!",
    "links": [
      {
        "label": "Repl.it Project: ",
        "url": "https://replit.com/@AmazingMech2418/LMC"
      }
    ],
    "images": ["/assets/repl/lmc-prog.PNG", "/assets/repl/lmc-display.PNG"],
    "score": 40
  },
  {
    "title": "Conway's Game of Life",
    "websites": ["Repl.it"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "BASIC"
    ],
    "thumbnail": "/assets/repl/conway.PNG",
    "description": "Shortly after the tragic passing of English mathemetician John Horton Conway, in 2020, I wanted to learn more about his famous cellular automation: Conways' Game of Life. In the Game of Life, any cell with 2 or 3 neighbors will keep its current state and any cell with 3 neighbors will turn on or \"come alive\". Using BASIC, I created a simulation of this, with the ability to pause and manipulate the cells by toggling them on and off. \n\nInvented in 1970, the Game of Life is the most well-known cellular automation and has even been found to be Turing-complete! Many mathematicians have even spent their entire lives studying its behavior, and the creation of different objects such as still lifes, gliders, and spaceships.",
    "links": [
      {
        "label": "Repl.it Project: ",
        "url": "https://replit.com/@AmazingMech2418/Conways-Game-of-Life"
      }
    ],
    "images": [],
    "score": 70
  },
  {
    "title": "Pong",
    "websites": ["Repl.it"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "BASIC"
    ],
    "thumbnail": "/assets/repl/pong.PNG",
    "description": "This is a recreation of the classic game, Pong! Made in BASIC, you can use the w and s keys to move the paddle. I attempted to most accurately recreate the game, although there might be some minor inconsistencies.",
    "links": [
      {
        "label": "Repl.it Project: ",
        "url": "https://replit.com/@AmazingMech2418/Pong"
      }
    ],
    "images": [],
    "score": 40
  },
  {
    "title": "Snake",
    "websites": ["Repl.it"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "BASIC"
    ],
    "thumbnail": "/assets/repl-logo.png",
    "description": "This is a recreation of the classic game, Snake! Made in BASIC, you can use WASD to move the snake. I attempted to most accurately recreate the game, although there might be some minor inconsistencies.",
    "links": [
      {
        "label": "Repl.it Project: ",
        "url": "https://replit.com/@AmazingMech2418/Snake"
      }
    ],
    "images": ["/assets/repl/snake.PNG"],
    "score": 40
  },
  {
    "title": "Representative Apportionment",
    "websites": ["Repl.it"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "Go"
    ],
    "thumbnail": "/assets/repl-logo.png",
    "description": "As I grew curious about how the votes in the electoral college and number of representatives in the House of Representatives were determined, I decided to create a program in Go to demonstrate the algorithm! Using population data from the US Census Bureau and the official algorithms for representative apportionment, this program will accurately display the number of representatives if they were apportioned in a particular year. Only 2019, 2016, and 2000 are available in this script, but any others can also be used with a proper API endpoint for the population data.",
    "links": [
      {
        "label": "Repl.it Project: ",
        "url": "https://replit.com/@AmazingMech2418/Representative-Apportionment"
      }
    ],
    "images": ["/assets/repl/apportionment.PNG"],
    "score": 65
  },
  {
    "title": "BookmarkletMaker",
    "websites": ["GitHub"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "JavaScript", "HTML"
    ],
    "thumbnail": "/assets/js-logo.png",
    "description": "On the Chromebooks we use for school, you can't do much. You can't even open the Chrome DevTools, because they are blocked. But you can use bookmarklets. As I learned more about the javascript: protocol and how it can be used to run JavaScript code, I created a website to allow you to create bookmarklets from basic JS scripts! This is that website. It has a few glitches, including broken links and that you cannot use double-quotes, but these are fixed in a later version I have yet to publish, which actually exists currently just as a bookmarklet. The new version also uses textarea elements instead of content-editable <p> tags, among other improvements!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/BookmarkletMaker"
      },
      {
        "label": "Live Website: ",
        "url": "https://amazingmech2418.github.io/BookmarkletMaker/home/"
      }
    ],
    "images": ["/assets/bookmarkletmaker.PNG"],
    "score": 68
  },
  {
    "title": "SpikeJump",
    "websites": ["GitHub"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "JavaScript", "HTML"
    ],
    "thumbnail": "/assets/spikejump/spikejump1.PNG",
    "description": "In 7th grade, two of my friends and I tried to start our own game development company, called Pomegranate Gaming. And as our first game, we were going to make a basic HTML5 game similar to the Google Chrome \"dinosaur game\". I unfortunately ended up being the only one to contribute to it at all, but I made SpikeJump, which was also my first ever HTML5 video game! I learned a lot from making it, although it maybe isn't the best quality.",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/PomegranateGaming/SpikeJump"
      },
      {
        "label": "Live Website: ",
        "url": "https://pomegranategaming.github.io/SpikeJump/"
      }
    ],
    "images": ["/assets/spikejump/spikejump1.PNG", "/assets/spikejump/spikejump2.PNG"],
    "score": 70
  },
  {
    "title": "CopyFile",
    "websites": ["GitHub"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "Batchfile"
    ],
    "thumbnail": "/assets/copyfile.PNG",
    "description": "When I was first learning Batchfile, I decided to make a basic command-line file copier! Using variables, user input, and file input/output, this project gave me a good foundation for future Batch scripts I have made. It doesn't work perfectly, however, since it can't copy binary files. But it can copy text-based files!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/CopyFile"
      }
    ],
    "images": [],
    "score": 65
  },
  {
    "title": "Jet!",
    "websites": ["GitHub"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "C#"
    ],
    "thumbnail": "/assets/unity-logo.png",
    "description": "Jet! was my first ever 3D Unity game! Although it relies heavily on prefabs, I was able to figure out how to shape the terrain, control the movement of the camera to align with the airplane, create a bounding box for the planes, and create a scoring system based on doing tricks. It is relatively glitchy and the textures didn't all upload properly when publishing to GitHub, but it taught me a lot about 3D game design and the Unity interface!",
    "links": [
      {
        "label": "GitHub Repository (distribution, not source code): ",
        "url": "https://github.com/AmazingMech2418/Jet"
      }
    ],
    "images": ["/assets/jet/jet1.PNG", "/assets/jet/jet2.PNG", "/assets/jet/jet3.PNG", "/assets/jet/jet4.PNG", "/assets/jet/jet5.PNG", "/assets/jet/jet6.PNG"],
    "score": 68
  },
  {
    "title": "Java JSON",
    "websites": ["GitHub"],
    "status": "Completed",
    "types": ["Software"],
    "langs": [
      "Java"
    ],
    "thumbnail": "/assets/java-logo.jpg",
    "description": "When I needed to parse JSON data in Java for my AP Computer Science class, I could have just looked for a library somewhere and loaded it into my IDE, but instead, I decided to make my own. And this is that JSON parser! Using ArrayLists and HashMaps to store the raw data and classes to act as wrappers, this allows advanced manipulation of JSON datasets in Java. It is slower than some other JSON parsers due to its recursive algorithm, but it still works and can parse large datasets relatively quickly!",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/Java-JSON"
      }
    ],
    "images": [],
    "score": 75
  },
  {
    "title": "Link Programming Language",
    "websites": ["GitHub"],
    "status": "In-Progress",
    "types": ["Software"],
    "langs": [
      "JavaScript", "HTML"
    ],
    "thumbnail": "/assets/github-logo.jpg",
    "description": "When I started experimenting with block-based programming language concepts, I thought about the possibility of a programming language based entirely on flowcharts. With the flow of data and the emulation of loops, it would seem relatively easy, as long as you could make the user interface. I then started working on Link, which uses JSON object blocks that are linked together by name in order to run programs. In the future, I hope to create the Flow programming language and the Flow-Link language stack to provide a flowchart-based user interface for programming with these concepts.",
    "links": [
      {
        "label": "GitHub Repository: ",
        "url": "https://github.com/AmazingMech2418/Link-Programming-Language"
      },
      {
        "label": "Demo Website: ",
        "url": "https://amazingmech2418.github.io/Link-Programming-Language/"
      }
    ],
    "images": [],
    "score": 75
  }
]
